<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Extrude Tool (GitHub Actions)</title>
  <style>
    body { margin:0; background:#111; color:#fff; font-family:sans-serif; }
    #controls { position:absolute; top:10px; left:10px; background:rgba(0,0,0,0.6); padding:10px; border-radius:8px; z-index:10; }
    label { display:block; margin:6px 0 2px; }
    input[type=range] { width:150px; }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="fileInput" accept=".png"><br>
    <label>Extrusion Depth: <span id="depthVal">0.3</span></label>
    <input type="range" id="depthSlider" min="0.1" max="2" step="0.1" value="0.3">
    <label>Smoothing: <span id="smoothVal">2</span></label>
    <input type="range" id="smoothSlider" min="0" max="10" step="1" value="2">
    <button id="exportBtn">Export & Upload</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/utils/ShapeUtils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/exporters/GLTFExporter.js"></script>

  <script>
    let scene, camera, renderer, mesh, currentTexture, currentShapes;
    let extrusionDepth = 0.3;
    let smoothingStrength = 2;

    init();

    function init() {
      scene = new THREE.Scene();
      camera = new THREE.PerspectiveCamera(45, window.innerWidth / window.innerHeight, 0.1, 1000);
      camera.position.z = 5;
      renderer = new THREE.WebGLRenderer({ alpha: true, antialias: true });
      renderer.setSize(window.innerWidth, window.innerHeight);
      document.body.appendChild(renderer.domElement);
      const light = new THREE.DirectionalLight(0xffffff, 1);
      light.position.set(5, 5, 5).normalize();
      scene.add(light);
      animate();
    }

    function animate() {
      requestAnimationFrame(animate);
      if (mesh) mesh.rotation.y += 0.01;
      renderer.render(scene, camera);
    }

    function simplifyPath(points, tolerance) {
      if (points.length < 3) return points;
      const sqTolerance = tolerance * tolerance;
      function getSqDist(p1, p2) { const dx = p1.x - p2.x, dy = p1.y - p2.y; return dx*dx + dy*dy; }
      function getSqSegDist(p, p1, p2) {
        let x = p1.x, y = p1.y; let dx = p2.x - x, dy = p2.y - y;
        if (dx !== 0 || dy !== 0) {
          const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx*dx + dy*dy);
          if (t > 1) { x = p2.x; y = p2.y; } else if (t > 0) { x += dx * t; y += dy * t; }
        }
        dx = p.x - x; dy = p.y - y; return dx*dx + dy*dy;
      }
      function simplifyDP(points, sqTolerance) {
        const len = points.length; const markers = new Uint8Array(len);
        let first = 0, last = len - 1; const stack = []; markers[first] = markers[last] = 1;
        while (last) {
          let maxSq = 0, index;
          for (let i=first+1;i<last;i++) {
            const sq = getSqSegDist(points[i], points[first], points[last]);
            if (sq > maxSq) { index=i; maxSq=sq; }
          }
          if (maxSq > sqTolerance) { markers[index]=1; stack.push({first,last:index}); stack.push({first:index,last}); }
          if (stack.length===0) break;
          const s = stack.pop(); first=s.first; last=s.last;
        }
        const newPts=[]; for (let i=0;i<len;i++) if (markers[i]) newPts.push(points[i]);
        return newPts;
      }
      return simplifyDP(points, sqTolerance);
    }

    function traceContours(imgData, smooth=2) {
      const { data, width, height } = imgData;
      const alphaThreshold = 128;
      function isSolid(x,y){ if(x<0||y<0||x>=width||y>=height)return false; return data[(y*width+x)*4+3]>alphaThreshold; }
      const visited = Array(width*height).fill(false); const shapes=[];
      function followContour(xStart,yStart){ let x=xStart,y=yStart,dir=0; const contour=[];
        do { contour.push(new THREE.Vector2(x,y)); visited[y*width+x]=true;
          let found=false;
          for(let i=0;i<4;i++){ const ndir=(dir+i)%4; const nx=x+[1,0,-1,0][ndir]; const ny=y+[0,1,0,-1][ndir];
            if(isSolid(nx,ny)&&!visited[ny*width+nx]){ x=nx;y=ny;dir=(ndir+3)%4;found=true;break; } }
          if(!found) break;
        } while(!(x===xStart&&y===yStart));
        return contour; }
      for(let y=0;y<height;y++){ for(let x=0;x<width;x++){ if(isSolid(x,y)&&!visited[y*width+x]){ let contour=followContour(x,y);
          if(contour.length>2){ if(smooth>0)contour=simplifyPath(contour,smooth); const shape=new THREE.Shape(contour); shapes.push(shape);} } } }
      return shapes;
    }

    function rebuildMesh() {
      if (!currentShapes || !currentTexture) return;
      const extrudeSettings = { depth: extrusionDepth, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(currentShapes, extrudeSettings);
      const material = new THREE.MeshPhongMaterial({ map: currentTexture, transparent:true, side:THREE.DoubleSide });
      if (mesh) scene.remove(mesh);
      mesh = new THREE.Mesh(geometry, material);
      mesh.scale.set(0.01, -0.01, 0.01);
      scene.add(mesh);
    }

    document.getElementById("fileInput").addEventListener("change", e => {
      const file = e.target.files[0]; if (!file) return;
      if (file.type!=="image/png") { alert("Only transparent PNGs allowed!"); return; }
      const reader=new FileReader();
      reader.onload=evt=>{
        const img=new Image();
        img.onload=()=>{
          const canvas=document.createElement("canvas"); canvas.width=img.width;canvas.height=img.height;
          const ctx=canvas.getContext("2d"); ctx.drawImage(img,0,0);
          const imgData=ctx.getImageData(0,0,canvas.width,canvas.height);
          currentShapes=traceContours(imgData,smoothingStrength);
          currentTexture=new THREE.TextureLoader().load(evt.target.result,rebuildMesh);
        };
        img.src=evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    document.getElementById("depthSlider").addEventListener("input", e=>{
      extrusionDepth=parseFloat(e.target.value);
      document.getElementById("depthVal").textContent=extrusionDepth;
      rebuildMesh();
    });
    document.getElementById("smoothSlider").addEventListener("input", e=>{
      smoothingStrength=parseInt(e.target.value);
      document.getElementById("smoothVal").textContent=smoothingStrength;
      rebuildMesh();
    });

    async function triggerWorkflow(glbBlob) {
      const repo = "hubcopilot/3d-extrude-tool";
      const token = "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"; // replace or proxy

      const reader = new FileReader();
      reader.onloadend = async () => {
        const base64Data = reader.result.split(",")[1];
        const response = await fetch(`https://api.github.com/repos/${repo}/actions/workflows/upload-model.yml/dispatches`, {
          method: "POST",
          headers: { "Accept":"application/vnd.github+json", "Authorization":`Bearer ${token}` },
          body: JSON.stringify({ ref:"main", inputs:{ model_file: base64Data } })
        });
        if(response.ok){
          alert("ðŸš€ Workflow triggered! Your model will be live soon at: https://YOUR_USERNAME.github.io/3d-extrude-tool/viewer.html");
        } else {
          const err=await response.json(); alert("âŒ Failed: "+JSON.stringify(err));
        }
      };
      reader.readAsDataURL(glbBlob);
    }

    document.getElementById("exportBtn").addEventListener("click", ()=>{
      if (!mesh) { alert("No 3D model!"); return; }
      const exporter=new THREE.GLTFExporter();
      exporter.parse(mesh, gltf=>{
        const blob=new Blob([JSON.stringify(gltf)],{type:"model/gltf+json"});
        triggerWorkflow(blob);
      });
    });
  </script>
</body>
</html>
