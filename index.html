<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8" />
  <title>3D Extrude Tool + Viewer</title>
  <style>
    body { margin:0; background:transparent; color:#fff; font-family:sans-serif; overflow:hidden; }
    #controls {
      position:absolute; top:10px; left:10px;
      background:rgba(0,0,0,0.6); padding:10px;
      border-radius:8px; z-index:10;
    }
    label { display:block; margin:6px 0 2px; }
    input[type=range] { width:150px; }
    #controls.hidden { display:none; }
  </style>
</head>
<body>
  <div id="controls">
    <input type="file" id="fileInput" accept=".png"><br>
    <label>Extrusion Depth: <span id="depthVal">0.3</span></label>
    <input type="range" id="depthSlider" min="0.1" max="2" step="0.1" value="0.3">
    <label>Smoothing: <span id="smoothVal">2</span></label>
    <input type="range" id="smoothSlider" min="0" max="10" step="1" value="2">
    <button id="exportBtn">Download GLB</button>
  </div>

  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/build/three.min.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/utils/ShapeUtils.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/exporters/GLTFExporter.js"></script>
  <script src="https://cdn.jsdelivr.net/npm/three@0.157.0/examples/js/loaders/GLTFLoader.js"></script>

  <script>
    // Scene setup
    let scene = new THREE.Scene();
    let camera = new THREE.PerspectiveCamera(45, window.innerWidth/window.innerHeight, 0.1, 5000);
    camera.position.z = 1000;
    let renderer = new THREE.WebGLRenderer({ alpha:true, antialias:true });
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    let light = new THREE.DirectionalLight(0xffffff, 1);
    light.position.set(5,5,5).normalize();
    scene.add(light);

    let mesh, currentTexture, currentShapes;
    let extrusionDepth = 0.3;
    let smoothingStrength = 2;

    // ðŸ”‘ If ?viewer is in URL â†’ hide controls + load /models/extruded.glb
    const urlParams = new URLSearchParams(window.location.search);
    if (urlParams.has("viewer")) {
      document.getElementById("controls").classList.add("hidden");
      const loader = new THREE.GLTFLoader();
      loader.load("models/extruded.glb", gltf => {
        mesh = gltf.scene;
        normalizeMesh(mesh);
        scene.add(mesh);
      });
    }

    function animate() {
      requestAnimationFrame(animate);
      if (mesh) mesh.rotation.y += 0.01;
      renderer.render(scene, camera);
    }
    animate();

    // ðŸŸ¢ Helpers
    function simplifyPath(points, tolerance) {
      if (points.length < 3) return points;
      const sqTolerance = tolerance * tolerance;
      function getSqSegDist(p, p1, p2) {
        let x = p1.x, y = p1.y, dx = p2.x - x, dy = p2.y - y;
        if (dx !== 0 || dy !== 0) {
          const t = ((p.x - x) * dx + (p.y - y) * dy) / (dx*dx + dy*dy);
          if (t > 1) { x = p2.x; y = p2.y; } else if (t > 0) { x += dx * t; y += dy * t; }
        }
        dx = p.x - x; dy = p.y - y; return dx*dx + dy*dy;
      }
      function simplifyDP(points, sqTolerance) {
        const len = points.length; const markers = new Uint8Array(len);
        let first = 0, last = len - 1; const stack = []; markers[first] = markers[last] = 1;
        while (last) {
          let maxSq = 0, index;
          for (let i=first+1;i<last;i++) {
            const sq = getSqSegDist(points[i], points[first], points[last]);
            if (sq > maxSq) { index=i; maxSq=sq; }
          }
          if (maxSq > sqTolerance) { markers[index]=1; stack.push({first,last:index}); stack.push({first:index,last}); }
          if (stack.length===0) break;
          const s = stack.pop(); first=s.first; last=s.last;
        }
        const newPts=[]; for (let i=0;i<len;i++) if (markers[i]) newPts.push(points[i]);
        return newPts;
      }
      return simplifyDP(points, sqTolerance);
    }

    function traceContours(imgData, smooth=2) {
      const { data, width, height } = imgData;
      const alphaThreshold = 128;
      function isSolid(x,y){ if(x<0||y<0||x>=width||y>=height)return false; return data[(y*width+x)*4+3]>alphaThreshold; }
      const visited = Array(width*height).fill(false); const shapes=[];
      function followContour(xStart,yStart){ let x=xStart,y=yStart,dir=0; const contour=[];
        do { contour.push(new THREE.Vector2(x,y)); visited[y*width+x]=true;
          let found=false;
          for(let i=0;i<4;i++){ const ndir=(dir+i)%4; const nx=x+[1,0,-1,0][ndir]; const ny=y+[0,1,0,-1][ndir];
            if(isSolid(nx,ny)&&!visited[ny*width+nx]){ x=nx;y=ny;dir=(ndir+3)%4;found=true;break; } }
          if(!found) break;
        } while(!(x===xStart&&y===yStart));
        return contour; }
      for(let y=0;y<height;y++){ for(let x=0;x<width;x++){ if(isSolid(x,y)&&!visited[y*width+x]){ let contour=followContour(x,y);
          if(contour.length>2){ if(smooth>0)contour=simplifyPath(contour,smooth); const shape=new THREE.Shape(contour); shapes.push(shape);} } } }
      return shapes;
    }

    function normalizeMesh(m) {
      const box = new THREE.Box3().setFromObject(m);
      const size = new THREE.Vector3();
      box.getSize(size);
      const maxDim = Math.max(size.x, size.y);
      const targetSize = 500;
      const scale = targetSize / maxDim;
      m.scale.set(scale, scale, scale);
      const center = new THREE.Vector3();
      box.getCenter(center);
      m.position.sub(center);
    }

    function rebuildMesh() {
      if (!currentShapes || !currentTexture) return;
      const extrudeSettings = { depth: extrusionDepth, bevelEnabled: false };
      const geometry = new THREE.ExtrudeGeometry(currentShapes, extrudeSettings);
      const material = new THREE.MeshPhongMaterial({ map: currentTexture, transparent:true, side:THREE.DoubleSide });
      if (mesh) scene.remove(mesh);
      mesh = new THREE.Mesh(geometry, material);
      normalizeMesh(mesh);
      scene.add(mesh);
    }

    // ðŸŸ¢ UI Bindings
    document.getElementById("fileInput").addEventListener("change", e => {
      const file = e.target.files[0]; if (!file) return;
      if (file.type!=="image/png") { alert("Only transparent PNGs allowed!"); return; }
      const reader=new FileReader();
      reader.onload=evt=>{
        const img=new Image();
        img.onload=()=>{
          const canvas=document.createElement("canvas"); canvas.width=img.width;canvas.height=img.height;
          const ctx=canvas.getContext("2d"); ctx.drawImage(img,0,0);
          const imgData=ctx.getImageData(0,0,canvas.width,canvas.height);
          currentShapes=traceContours(imgData,smoothingStrength);
          currentTexture=new THREE.TextureLoader().load(evt.target.result,rebuildMesh);
        };
        img.src=evt.target.result;
      };
      reader.readAsDataURL(file);
    });

    document.getElementById("depthSlider").addEventListener("input", e=>{
      extrusionDepth=parseFloat(e.target.value);
      document.getElementById("depthVal").textContent=extrusionDepth;
      rebuildMesh();
    });

    document.getElementById("smoothSlider").addEventListener("input", e=>{
      smoothingStrength=parseInt(e.target.value);
      document.getElementById("smoothVal").textContent=smoothingStrength;
      rebuildMesh();
    });

    // ðŸŸ¢ Export button â†’ download GLB
    document.getElementById("exportBtn").addEventListener("click", ()=>{
      if (!mesh) { alert("No 3D model!"); return; }
      const exporter=new THREE.GLTFExporter();
      exporter.parse(mesh, gltf=>{
        const blob=new Blob([JSON.stringify(gltf)],{type:"model/gltf+json"});
        const a=document.createElement("a");
        a.href=URL.createObjectURL(blob);
        a.download="extruded.glb";
        a.click();
      });
    });

    window.addEventListener("resize", ()=>{
      camera.aspect=window.innerWidth/window.innerHeight;
      camera.updateProjectionMatrix();
      renderer.setSize(window.innerWidth, window.innerHeight);
    });
  </script>
</body>
</html>
